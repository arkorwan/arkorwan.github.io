---
layout: post
title: Advent of Code 2019 part 1 – The Intcode Computer Challenge 
tags: [programming, puzzle]
---

ช่วงปลายปีที่แล้วมี[เพื่อน](https://twitter.com/PrachP)แนะนำให้รู้จักเว็บ [Advent of Code](https://adventofcode.com/2019)
เป็นเว็บแนว programming contest เว็บหนึ่ง จุดเด่นก็คือ ตัวโจทย์จะถูกออกแบบมาในแนว puzzle ซะมากกว่า
คือไม่ได้ระบุ input/output มาแบบชัดเป๊ะเหมือนเว็บอื่นๆ แต่ผู้เล่นต้องพยายามแกะ requirement จากคำใบ้ด้วย
บางครั้งต้องทดลองรันโปรแกรมแบบครึ่งๆ กลางๆ เพื่อ probe ดูปัญหาว่ามี hidden requirement อะไรบ้าง
เป็นความท้าทายที่แตกต่างไปจากโจทย์ programming ปกติ

<!--more-->

โจทย์มีทั้งหมด 25 วัน แต่ละวันเป็นปัญหาสองข้อ ยกเว้นวันสุดท้ายที่มีแค่ข้อเดียว นับรวมข้อย่อยทั้งหมดได้ 49 ข้อ
หลายข้อที่เป็นโจทย์ต่อเนื่องกัน คือการสร้าง interpreter เพื่อรัน machine language ตัวหนึ่ง ซึ่งก็คือหัวข้อของเราในโพสนี้

## 'Intcode Computer'

ครึ่งหนึ่งของปัญหาทั้งหมดเป็นโจทย์ที่ให้เราสร้างโปรแกรมเพื่อรัน machine language ซึ่งทางเว็บตั้งชื่อไว้ว่า Intcode Computer[^1]
โจทย์ข้อแรกๆ (วันที่ 2, 5, 7, 9) จะเป็นการค่อยๆ เพื่ม spec ให้ภาษานี้ ข้อหลังๆ ของโจทย์ชุดนี้คือเราจะได้ input มาเป็นโปรแกรม Intcode เลย
แล้วเป็นหน้าที่ของเราที่ต้องเขียน interface โต้ตอบกับโปรแกรมที่ได้มา เหมือนได้กลับไปเรียนเขียนโค้ดกับพวก logic board โดยตรงอีกครั้ง

Spec ที่สมบูรณ์ของ Intcode มีผู้[รวบรวม](https://esolangs.org/wiki/Intcode)ไว้แล้ว
ตรงนี้ขอสรุปย่อๆ ว่า Intcode เป็นภาษาที่ประกอบจาก instruction และ data ที่เป็นลิสต์ของจำนวนเต็มทั้งหมด
มีความสามารถในการคำนวณ, การเปรียบเทียบ, flow control, และยังมี addressing mode หลากหลายรูปแบบ
เพื่อรองรับทั้ง global และ local variable รวมถึงการตีความ data เป็นได้ทั้งค่าจำนวนเต็มและ address 
ทั้งหมดนี้ทำให้ Intcode เป็นภาษาที่ -- นอกจากจะ Turing complete แล้ว -- ยังสามารถเทียบเคียงกับ concept ในภาษาระดับสูงได้อย่างไม่ยากเย็นนัก

ผมค่อยๆ สร้าง [class IntCode](https://github.com/arkorwan/advent-of-code/blob/master/2019/intcode.rb)[^0] เพิ่มความสามารถ ปรับแต่งไปเรื่อยๆ ตามที่ spec ที่ได้เพิ่มมา ท้ายที่สุดได้คลาสที่มี public method ดังนี้

* push(input: Integer) -- รับเลขหนึ่งตัว ใส่ลงไปที่ input queue
* push_all(inputs: Array\[Integer\]) -- ใส่เลขทั้งหมดใน input array ลงไปที่ input queue
* push_string(input: String) -- รับ string แปลงเป็น ascii code ใส่ลงไปที่ input queue
* run -- run โปรแกรมไปจนกระทั่ง halt, หรือจนกว่าจะต้องการ input เพิ่มเติม (คือเจอ input instruction แล้วไม่มี input อยู่ใน input queue)
return output ที่ได้ทั้งหมดเป็น array
* run_string -- เหมือน run แต่แปลง output ที่ได้เป็น string โดยถือว่าเลขที่มีค่าน้อยกว่า 128 คือ ascii code, เลขที่มากกว่านั้นคือตัวเลขธรรมดา
* clone -- ทำ deep copy ของ state ปัจจุบันของโปรแกรม ออกมาอีก instance หนึ่ง

โจทย์ข้อแรกๆ จะยังไม่ค่อยมีอะไรมากไปกว่าการแนะนำ spec ของ Intcode เราจะข้ามไปดูโจทย์ที่เอา Intcode มาใช้งานเลยดีกว่า

## [Day 11](https://adventofcode.com/2019/day/11)

ข้อนี้เป็นข้อแรกหลังจาก Intcode spec สมบูรณ์ 
เราจะได้ input มาเป็นโปรแกรม Intcode ซึ่งควบคุมหุ่นยนต์เพื่อทาสีบน square grid
โปรแกรมจะอ่านค่าสีบนพื้น (0 หรือ 1) แล้วจะ return สีที่ต้องทาทับลงไป กับทิศทางว่าจะให้หันซ้ายหรือขวา
จนกระทั่งเจอ halt instruction ก็หยุดทำงาน

Part 1 ถามว่า ถ้า input แรกเป็น 0 หุ่นจะทาสีลงไปกี่ช่อง

Part 2 ให้เปลี่ยน Input แรกเป็น 1 แล้วถามว่าเราเห็นตัวอักษรอะไรบนพื้น 

ที่จริงโจทย์ข้อนี้ไม่ได้มีอะไรซับซ้อน เราก็แค่เก็บพิกัดที่ทาสีไปแล้วไว้ใน hash อันหนึ่ง แล้วก็ simulate ไปจนจบ
หลังจากรัน part 2 เราก็จะได้ output แบบนี้

<div class='asciiart-container'><pre class='asciiart'>
 ■  ■   ■■  ■■  ■      ■■ ■■■■ ■■■■ ■  ■   
 ■  ■    ■ ■  ■ ■       ■    ■ ■    ■  ■   
 ■■■■    ■ ■  ■ ■       ■   ■  ■■■  ■■■■   
 ■  ■    ■ ■■■■ ■       ■  ■   ■    ■  ■   
 ■  ■ ■  ■ ■  ■ ■    ■  ■ ■    ■    ■  ■   
 ■  ■  ■■  ■  ■ ■■■■  ■■  ■■■■ ■    ■  ■   
</pre>
<br><em>HJALJZFH!</em>
</div>

เป็นตัวอักษรจริงด้วย!

ข้อนี้ทำให้ผม appreciate ขึ้นมาอย่างนึงว่า เฮ้ย ไอ้โปรแกรม Intcode (และคนตั้งโจทย์) นี่มันไม่ธรรมดานะเนี่ย
ทำงานได้ซับซ้อนเลยทีเดียว คือจริงๆ ถ้าเห็นเป็นโค้ดใน high-level langauge ที่เราใช้กันทั่วไปมันก็คงเฉยๆ
แต่พอ input มันเป็น low level เป็นเลขยาวๆ เราก็เลยรู้สึกประทับใจอยู่นะ! ถึงแม้จริงๆ คนตั้งโจทย์เค้าก็คงจะต้อง generate โปรแกรมนี่ด้วย compiler
มาจาก high-level DSL อะไรซักอย่างนั่นแหละ

## [Day 13](https://adventofcode.com/2019/day/13)

ข้อนี้เพิ่มความซับซ้อนของโปรแกรม Intcode ขึ้นไปอีกระดับ

Part 1 ไม่มี input อะไร โปรแกรมจะ output เลขออกมายาวๆ เป็นตำแหน่งของ game object เลขทุกๆ 3 ตัวจะบอกพิกัด x,y และบอกว่า
ตำแหน่งนั้นเป็น object อะไร กำแพง บล็อก ลูกบอล paddle หรือที่ว่าง โจทย์ part แรกถามง่ายๆ ว่ามี tile ที่เป็นบล็อกอยู่กี่อัน ก็แค่นับแล้วตอบ ตรงไปตรงมา

แต่เราก็อยากรู้ว่า game object ที่ให้มาตั้งหลายแบบ แต่ดันถามอยู่แบบเดียว แล้วไอ้ที่เหลือมันประกอบขึ้นเป็นเกมหน้าตายังไง ก็เลยลองเขียนให้มัน print ออกมาดู

<div class='asciiart-container'><pre class='asciiart'>
########################################
#                                      #
#   ■  ■■■■ ■  ■  ■■■■     ■ ■ ■■■ ■   #
# ■■■ ■■  ■ ■■■■■■  ■■   ■■  ■■ ■■■■ ■ #
#  ■■ ■■■■ ■■■■ ■ ■■  ■■■ ■■■■■■  ■■   #
# ■■■■ ■■■■ ■■■■ ■■   ■     ■  ■■ ■  ■ #
# ■■■■■ ■ ■ ■ ■■■■ ■ ■■■ ■■■■■■ ■■■ ■  #
#  ■ ■■■■ ■  ■ ■■     ■■■  ■ ■■ ■■     #
#  ■  ■■■■■■■■■■■ ■  ■■■■■ ■■■  ■   ■  #
#  ■■ ■ ■■■     ■■■■■■■  ■  ■ ■■■■■ ■■ #
#  ■■■■ ■   ■■■ ■ ■      ■■ ■■  ■■■■■■ #
#   ■ ■  ■ ■ ■  ■ ■■  ■       ■■ ■■■■  #
#  ■■■ ■ ■ ■■■■■■■■■■ ■   ■ ■ ■ ■■■■■■ #
# ■ ■ ■■  ■■■■■■■ ■■   ■■ ■■  ■ ■■■■   #
#  ■  ■■       ■     ■ ■■■  ■ ■■ ■■■■■ #
# ■  ■  ■■■   ■■■■■■■ ■■■■■■  ■■ ■  ■■ #
# ■■  ■■■■ ■■■■    ■ ■■■ ■   ■ ■    ■  #
# ■■ ■■■ ■■■■■■■■■■■■■        ■ ■■■■ ■ #
#                                      #
#                 O                    #
#                                      #
#                                      #
#                   =                  #
#                                      #
</pre></div>

มันคือ เกมคลาสสิกในตำนาน [Breakout](https://en.wikipedia.org/wiki/Breakout_(video_game)) นั่นเอง

---

โจทย์ใน Part 2 บอกให้เราใส่ input เข้าไปที่โปรแกรม Intcode เพื่อขยับ paddle ทำลายบล็อกให้หมด
แล้วให้เอาคะแนนที่ได้มาเป็นคำตอบ ก็คือบอกให้เราเคลียร์เกมนี้ให้ได้นั่นละ

ผมก็เลยคิดว่า งั้นเราทำเป็น interactive mode เขียน TUI ด้วย curses (ซึ่งก็ไม่เคยเขียนมาก่อนเลย)
แล้วเล่นเองจริงๆ เลยดีกว่า ผลออกมาเป็น [code](https://github.com/arkorwan/advent-of-code/blob/master/2019/p13_p2game.rb) นี้

ซึ่งก็เล่นได้จริงๆ แต่ถ้าจะใช้แก้โจทย์ มันไม่เวิร์คครับผม แป่ว

สาเหตุก็คือ ผมถูกหลอกจากความคุ้นเคยกับเกมเกินไป นี่ไม่ใช่ action game เหมือนอย่างเกม breakout ในชีวิตจริง
แต่เป็น turn-based ต่างหาก!

คือทุกครั้งที่เราใส่ input เข้าไป จะขยับ paddle ได้แค่ช่องเดียว พร้อมๆ กันนั้น ลูกบอลก็จะขยับไป 1 ช่องเช่นกัน
ในขณะที่ breakout จริงๆ เราต้องใช้ปฏิกิริยาที่รวดเร็วในการตามลูกบอลให้ทัน
แต่ในกรณีนี้ เราไม่สามารถทำความเร็วแซงลูกบอลได้เลย ดังนั้นวิธีการเล่นจึงต้องเป็นการเลื่อน paddle เพื่อ track ตำแหน่งในแกน x ของลูกบอลไว้ตลอด
ถ้าขยับผิดข้างเมื่อไหร่ paddle จะอยู่ห่างจากบอล 2 ตำแหน่ง เรียกได้ว่าแทบจะแพ้ในทันที

ซึ่งงานแบบนี้มันเหมาะให้เครื่องทำมากกว่ามานั่งจิ้มเองแน่ๆ สุดท้ายก็เลยต้องเขียนเป็น [code](https://github.com/arkorwan/advent-of-code/blob/master/2019/p13_p2.rb) แก้อัตโนมัติอยู่ดี
แต่ไหนๆ ก็อุตส่าห์ทำ interface ไว้แล้ว ผมก็เลยให้เก็บ interface นี้ไว้เป็น display แล้วมานั่งดูคอมเล่นแทน ฮ่าๆ

[![](https://i.postimg.cc/J7ZxL4ZR/p13.gif#center)](https://postimg.cc/3Wrmjhtq)

## [Day 15](https://adventofcode.com/2019/day/15)

ข้อต่อไป ตัวโปรแกรม Intcode ยังคงเป็นโปรแกรมควบคุมหุ่น คราวนี้รับ input เป็นทิศ เหนือ-ใต้-ออก-ตก ให้หุ่นเดินตามสั่ง เพื่อไปให้ถึงจุดหมาย
โดยที่ในแต่ละคำสั่งเราจะได้ output กลับมาว่า เดินได้ เดินไม่ได้ (ติดกำแพง) หรือ ถึงเป้าหมายแล้ว

โจทย์ part 1 ถามว่า shortest path ในการไปให้ถึงเป้าหมายนั้น มีระยะทางเท่าไหร่?

ปกติเวลาแก้โจทย์ shortest path ใน grid แบบนี้เราแก้ได้ง่ายๆ ด้วย flood-fill / breadth-first search
ก็คือเริ่มจากจุดสตาร์ต มีความยาว path เป็น 0 แล้วค่อยๆ probe ออกไปหา cell ใหม่ๆ ถ้าได้ cell ใหม่ก็เพิ่มความยาว path ไปอีก 1
แล้วเก็บใส่ queue ไว้ เอา cell จากใน queue มาทำแบบนี้วนไปเรื่อยๆ ก็จะได้ความยาว path จากจุดสตาร์ตถึงทุก cell

ปัญหาก็คือ ตามอัลกอริธึม เราจะต้องดำเนินการตามลำดับของ cell ใน queue ซึ่งผมไม่สามารถบังคับให้หุ่น "วาร์ป" จาก cell หนึ่งไปยังอีก cell หนึ่ง (ซึ่งโดยทั่วไปแล้วไม่ได้อยู่ติดกัน) ได้ในทันที
แต่ต้องบังคับให้มันเดินไป จะทำ flood-fill ก็ลำบากละ
ก็เลยเปลี่ยนไปคิดว่างานนี้ต้องเขียน maze solver แทนจริงๆ มั้ยนะ แบบให้หุ่น track กำแพงด้านซ้ายไว้ตลอดอะไรทำนองนี้ แต่เอ๊ะแล้วถ้ามันมี loop เราจะอัพเดตค่า shortest path ยังไงนะ ...

คิดวนไปมาสักพักก็เปลี่ยนใจ เลิกคิดดีกว่า ไหนๆ เราก็มีโค้ดเขียน interface จากข้อก่อนหน้านี้แล้ว ก็เอามาทำเป็น [interactive code](https://github.com/arkorwan/advent-of-code/blob/master/2019/p15_ia.rb) อีกสักข้อเพื่อให้เราคุมหุ่นแบบ manual ไปเลย
คือถ้าเดินได้ก็จะวาดเป็นจุด (.) ออกมาว่าเดินไปแล้วนะ ถ้าเดินชนกำแพงก็วาดกำแพง (■) ออกมาเลย

ซึ่งผลลัพธ์ของวิธีการนี้ก็คล้ายๆ กับข้อที่แล้ว คือแก้ manual แบบนี้มันก็แก้ได้ แต่ให้คอมทำน่าจะดีกว่า ...
แต่คราวนี้ผมลุยถึกไปนี่แหละ จนวาด map ออกมาได้แบบนี้ เสร็จแล้วต้องรีบเซฟเก็บไว้ ฮ่าๆ

<div class='asciiart-container'><pre class='asciiart'>
                                          
  ■■■■■ ■■■■■ ■■■■■ ■■■■■■■ ■■■■■ ■■■ ■■■ 
 ■.....■.....■.....■.......■.....■...■...■
 ■.■■■.■.■■■.■.■■■.■.■.■■■■■.■.■.■.■.■.■.■
 ■.■.■.■..X■.....■.■.■.......■.■.■.■...■.■ 
 ■.■.■.■■■■■.■■■■■.■.■■■■■■■■■.■■■.■■■■■.■
 ■...■.....■.■.....■.■...■...■...■.■.■...■
  ■■.■■■■■.■■■.■■■.■.■.■.■.■.■■■.■.■.■.■.■
 ■.■.■...■.■...■...■.■.■...■...■.■...■.■.■
 ■.■.■.■■■.■.■■■■■■■.■.■■■■■■■.■.■■■.■.■■ 
 ■.■.■.■...■.■.....■.■...■.....■.....■...■
 ■.■.■.■.■■■.■.■■■.■.■■■.■■■.■■■■■■■■ ■■.■
 ■...■.■...■.....■.■...■...■.■...■...■.■.■
 ■.■■■.■■■.■■■■■.■.■■■.■■■.■.■.■.■.■.■.■.■
 ■.....■.■.....■.■.........■...■.■.■...■.■
  ■■■■.■.■■■■■.■■■■■■■.■■■■ ■■■■.■.■■■■■.■
 ■...■.■.■...■.■.....■.■...■...■...■.....■
 ■.■.■.■.■.■.■.■.■■■.■.■.■.■.■.■■■■■.■■■.■
 ■.■.■.■...■.■...■...■.■.■...■.......■...■
 ■.■.■.■■■■■.■■ ■■.■■■■■.■.■■■■■■■■■■■.■■ 
 ■.■.■.........■.■.....■.■.■...■.....■.■.■
 ■.■.■■■■■■■■■.■.■■■■■.■.■■■.■.■■■.■■■.■.■
 ■.■.■.......■.■.....■^■.■...■...■.....■.■
 ■.■■■.■.■■■■■.■.■■■.■■■.■.■■■■■.■■■.■■■.■
 ■.■...■.....■...■...■...■.....■...■.....■
 ■.■.■■■■■■■.■■■■■.■■■■■.■■■■■.■■■.■■■■■.■
 ■.■.■.....■.....■.....■...■...■.■.■.....■
 ■.■.■■■.■■■■■■■.■■■■■.■.■■■.■■■.■.■■■■■■ 
 ■.■.■...■.....■.....■.■.........■.■.....■
 ■.■.■.■■■.■■■.■■■.■■■.■■■■■■■■■■■.■.■■■.■
 ■.■.■.......■...■...■...........■.....■.■
 ■.■.■■■.■■■■■■■.■■■.■■■■■■■■■■■.■■■■■■■.■
 ■.■...■...■.....■.■...■.......■.....■...■
 ■.■■■.■■■■■.■■■.■.■■■.■.■■■.■.■■■■■.■.■■ 
 ■...■.■.....■...■...■.■.■.■.■...■...■...■
  ■■.■.■.■■■■■.■■■.■.■.■.■.■.■■■■■.■■■■■.■
 ■...■.■...■...■...■.■.■...■.....■.■.....■
 ■.■■■.■.■.■■■.■■■■■.■.■■■.■■■■■.■.■.■■■.■
 ■.....■.■...■...■...■.....■.■...■...■.■.■
 ■.■■■■■■■■■.■■■.■.■.■■■■■■■.■.■■■■■■■.■.■
 ■...........■.....■.........■...........■
  ■■■■■■■■■■■ ■■■■■ ■■■■■■■■■ ■■■■■■■■■■■ 
                                          
</pre>
<br><em>start ตรงกลางที่ตำแหน่ง ^ ไปจบซ้ายบนที่ X</em>
</div>

ส่วนคำตอบ เราโชคดีที่โจทย์ปรานี มี hidden requirement ว่า maze ที่ให้มามันไม่มีการวนลูป ดังนั้นเราก็แค่นับระยะ +1 ไปจาก cell ก่อนหน้าไปเรื่อยๆ ไม่ต้องกังวลการ update ค่าเก่า ก็เลยง่ายหน่อย

---

ส่วน part 2 นั้นแค่ให้หา cell ที่อยู่ไกลจากจุดเป้าหมายมากที่สุด ซึ่งตอนนี้เรามี map ทั้งหมดเซฟเก็บไว้แล้ว ก็แค่ใช้ flood-fill หาคำตอบได้สบายๆ

---

หลังจากส่งคำตอบไปแล้ว ผมไปแอบดูใน reddit ก็ได้ไอเดียเพิ่มมาว่า จริงๆ part แรก มันก็แก้ด้วย flood-fill ได้แหละ
ที่ผมติดอยู่ตอนแรกก็คือเราไม่สามารถวาร์ปหุ่นไปมาได้เพราะต้องให้มันเดินตามทาง
ตรงนี้ผมไปติดกับดัก คิดจริงจังกับเนื้อเรื่อง (เหมือนข้อ Breakout อีกแล้ว)
คือไปคิดว่า ตัวโปรแกรม Intcode นี่มันฝังอยู่ในตัวหุ่น เราบังคับหุ่นอยู่จริงๆ
ไม่ได้นึกถึงว่า ที่จริงเราสร้าง copy ของโปรแกรมใน state สำหรับแต่ละ cell ขึ้นมาก็ได้
ก็คือพอเดินไปถึง cell ไหน เราก็ clone โปรแกรมออกมา วางไว้ที่ cell นั้น
ทีนี้เราอยากจะวาร์ปไป cell ไหน ก็จะมีโปรแกรม Intcode ใน state ที่ถูกต้องให้เราใช้ได้ ไม่ต้องบังคับให้หุ่นมันเดินตามทางจริงๆ
ซึ่งทำให้สามารถใช้ flood-fill ได้อย่างที่ตั้งใจไว้ทีแรก

clone method จึงถูกเพิ่มเข้าไปในคลาส Intcode ด้วยประการฉะนี้

## [Day 21](https://adventofcode.com/2019/day/21)

ข้อถัดไป โปรแกรม Intcode ก็ยังถูกใช้ควบคุมหุ่นอีกเช่นเคย ที่ผ่านมาเราเจอหุ่นในเกมแนว action/arcade แนว maze กันแล้ว
ทีนี้มาเป็นแนว platformer บ้าง

ตัวหุ่นในข้อนี้วิ่งจากซ้ายไปขวา แล้วต้องกระโดดข้ามช่องว่าง โจทย์ให้เราเขียน logic คุมหุ่นให้กระโดดอัตโนมัติจากสิ่งที่หุ่นเห็นข้างหน้า
logic ที่เขียนมีหน้าตาเป็นภาษาแนวๆ assembly language ชนิดหนึ่ง ซึ่งมี operator ให้ใช้แค่ AND, OR และ NOT
ถ้าตั้ง register ที่ชื่อ J ให้เป็น true หุ่นก็จะกระโดด ถ้าเป็น false ก็ไม่กระโดด
และมีข้อจำกัดให้เขียนได้แค่ 15 คำสั่งเท่านั้น ส่งเป็น input ให้ Intcode computer 
เมื่อเราใส่ logic เข้าไปแล้ว ตัวโปรแกรมจะรัน logic นั้นกับ test case ต่างๆ เพื่อดูว่ากระโดดผ่านทั้งหมดหรือไม่

ใน part 1 หุ่นมองเห็น 4 ช่องล่วงหน้า (ใช้สัญลักษณ์ A, B, C, D ตามลำดับจากใกล้ไปหาไกล)
และการกระโดดแต่ละครั้งหุ่นจะกระโดดข้ามไป 3 ช่อง ไปที่ช่องที่ 4
(ซึ่งตรงนี้โจทย์ไม่ได้บอกมา ต้องเดาเอาเองจากตัวอย่างและการลองผิดลองถูก) เราจะวาง logic ยังไงดี?

ถ้าให้ `.` คือช่องว่าง, `#` คือพื้น และ `?` คือ wildcard เป็นพื้นหรือช่องว่างก็ได้ และช่องที่หุ่นอยู่ปัจจุบันคือช่องที่ i
ถ้ากระโดดจะไปอยู่ที่ i+4 ถ้าไม่กระโดดก็จะเดินไปที่ i+1

ผมได้กฎการกระโดดแบบนี้

- `.???` → JUMP! อันนี้คือถ้าช่องข้างหน้า (i+1) เป็นช่องว่าง เดินไปก็ตายสถานเดียว ยังไงก็ต้องกระโดด
- `???.` →  NOT JUMP! อันนี้ตรงกันข้าม คือช่อง i+4 เป็นช่องว่าง ถ้าโดดไปก็ตกพอดี ยังไงก็ต้องไม่กระโดด
- `####` → NOT JUMP! กรณีนี้เรามองได้ว่า การกระโดดไปยังช่อง i+4 เราอาจจะเลือกเดินไป 4 ครั้ง ก็สามารถไปถึงช่อง i+4 ได้หมือนกัน
แต่ถ้าเลือกเดินไปจะมีข้อได้เปรียบ คือเราจะมีข้อมูลเพิ่มขึ้นเรื่อยๆ ในการเดินแต่ละครั้ง เราอาจจะพบว่า ช่อง i+4 ไม่ใช่ช่องที่ดี เปลี่ยนใจกระโดดหนีได้
ดังนั้นการเลือกเดินไปจึงเป็นทางเลือกที่เปิดโอกาสให้เรามากกว่าเสมอ
- `#?.#` -> JUMP! case ที่ยังไม่ครอบคลุมโดยกฎข้างบนจะเหลืออยู่ 3 แบบ คือ `#.##`, `##.#` และ `#..#`
ซึ่งทั้ง 3 แบบนี้มีช่องว่างอยู่ ยังไงซะเราจะต้องกระโดดแน่ๆ ภายใน 3 turn ไอเดียตรงนี้ก็คือ ถ้ารู้ตัวแล้วว่าต้องกระโดด
ยิ่งโดดเร็วก็ยิ่งดี เพราะจะมีทางเลือกในอนาคตมากกว่า ซึ่งตอนหลังผมทดลองดูแล้ว พบว่าเช็คแค่ข่อง i+3 ก็พอ
คือตัดเคส `#.##` ออกไปก็ได้ (เพื่อลดจำนวน instructions ที่เรามีโควต้าจำกัด) ก็เลยกลายเป็นกฎ `#?.#` แบบนี้

ทั้งหมดนี้เขียนเป็น expression ได้ว่า

~~~~
J ← ¬A ∨ (¬C ∧ D)
~~~~
หรือ
~~~~
J ← (¬A ∨ ¬C) ∧ D
~~~~
สองแบบนี้ให้ผลต่างกันเล็กน้อยในกรณีที่ทั้ง A และ D เป็น false ทั้งคู่ ซึ่งก็คือทั้งช่อง i+1 และ i+4 เป็นช่องว่าง
แบบแรกหุ่นจะกระโดด แบบที่สองจะไม่กระโดด แต่ไม่ว่าจะกระโดดหรือไม่ก็ตายอยู่ดี ดังนั้นในทางปฏิบัติแล้วไม่ได้มีผลต่างกัน
ผมเลือก implement แบบแรก
และสามารถรัน test ผ่านโดยใช้ 4 instructions

~~~~
NOT C J   # J ← ¬C
AND D J   # J ← J ∧ D --- expands to J ← ¬C ∧ D
NOT A T   # T ← ¬A
 OR T J   # J ← T ∨ J --- expands to J ← ¬A ∨ (¬C ∧ D)
~~~~

---

โจทย์ part 2 เพิ่มให้เรา lookahead ได้ 8 ช่อง จากเดิม 4 ช่อง แลกมาด้วย test case ที่ซับซ้อนยิ่งขึ้น
ผมลองเอา solution จาก part 1 มาใช้กับ part 2 ก็จะเจอ test case ที่รันไม่ผ่าน แบบนี้

[![](https://i.postimg.cc/0QmYPc6V/p21.gif#center)](https://postimg.cc/BLSLC5BF)

จะเห็นว่า เคสนี้ที่หุ่นเราโดดไม่ผ่าน ก็เพราะการกระโดดครั้งแรกมันกระโดดไปที่จุดตาย คือจุดที่ i+1 และ i+4 เป็นหลุมทั้ง
ดังนั้น step ต่อไปยังไงก็ตาย แสดงว่า logic เราต้องหลึกเลี่ยงการเข้าไปสู่จุดตายลักษณะนี้ด้วย

เราจะใช้ predicate `dead(x)` เพื่อบอกว่า ตำแหน่ง x เป็นจุดตาย
ซึ่งเรา define มันแบบ recursive ก็คือ ช่องที่ x จะเป็นจุดตาย ถ้า
1. มันเป็นหลุม หรือ
1. ช่อง x+1 และ x+4 เป็นจุดตายทั้งคู่

~~~~
dead(x) = ¬x ∨ (dead(x+1) ∧ dead(x+4))
~~~~

เราเอา expression จาก part 1 มาเขียนใหม่ได้เป็นแบบนี้
~~~~
J ← dead(A) ∨ (¬C ∧ ¬dead(D))
~~~~
ซึ่งเราขยาย predicate ออกมาแค่ครั้งเดียวใน part 1 โดยตัด recursive case ออกไป แต่ถ้าเรา expand ออกไปอีกรอบ ก็จะได้ expression แบบนี้
~~~~
    J ← dead(A) ∨ (¬C ∧ ¬dead(D))
(1) J ← (¬A ∨ (dead(B) ∧ dead(E))) ∨ (¬C ∧ ¬(¬D ∨ (dead(E) ∧ dead(H))))
(2) J ← (¬A ∨ (¬B ∧ ¬E)) ∨ (¬C ∧ ¬(¬D ∨ (¬E ∧ ¬H)))
(3) J ←  ¬A ∨ ¬(B ∨ E) ∨ (¬C ∧ D ∧ (E ∨ H))
~~~~

หลังจาก simplify ใน step (3) แล้ว เราเอามาเขียนเป็น instructions[^2]

~~~~
NOT C J  # J ← ¬C
AND D J  # J ← J ∧ D --- expands to J ← ¬C ∧ D
 OR E T  # T ← E
 OR H T  # T ← T ∨ H --- expands to T ← E ∨ H
AND T J  # J ← J ∧ T --- expands to J ← ¬C ∧ D ∧ (E ∨ H)
NOT A T  # T ← ¬A
 OR T J  # J ← T ∨ J --- expands to J ← ¬A ∨ (¬C ∧ D ∧ (E ∨ H))
 OR B T  # T ← T ∨ B --- expands to T ← ¬A ∨ B
 OR E T  # T ← T ∨ E --- expands to T ← ¬A ∨ B ∨ E
NOT T T  # T ← ¬T     --- expands to T ← ¬(¬A ∨ B ∨ E)
 OR T J  # J ← T ∨ J --- expands to J ← ¬A ∨ ¬(¬A ∨ B ∨ E) ∨ (¬C ∧ D ∧ (E ∨ H))
~~~~

ซึ่งพอเอา instructions นี้ไป run ก็ผ่าน test case ได้ทั้งหมด

สรุปแล้ว ข้อนี้มันไม่ใช่โจทย์โปรแกรมมิ่งเลยซักนิด เป็นโจทย์ตรรกศาสตร์ แก้ได้ด้วยกระดาษกับปากกานี่ล่ะ

## [Day 25](https://adventofcode.com/2019/day/25)

ข้อสุดท้ายของ Intcode และก็เป็นข้อสุดท้ายของ Advent of Code ปีนี้ มีแค่ part เดียว
คราวนี้เป็นเกมแนว text-based adventure

ตัวโปรแกม Intcode รอบนี้ รับ input เป็นคำสั่งควบคุมตัวละคร
ให้เดินไปในห้องตามทิศ north / east / south / west
หรือ take/drop ของจาก inventory
ตัวโปรแกรมจะ return ข้อความออกมาเป็นคำบรรยายห้องปัจจุบัน

โจทย์บอกให้เราสำรวจฉาก เพื่อเก็บ item ซึ่งจะมีน้ำหนักต่างๆ กัน แล้วหาห้องเป้าหมายซึ่งจะมีเซนเซอร์ตรวจจับน้ำหนัก
แล้วพยายามถือของให้มีน้ำหนักรวมตรงกับค่าที่เซนเซอร์ต้องการ

แน่นอน ผมก็ทำเป็น interactive game ตรงๆ แล้วเล่นแบบ manual อีกเช่นเคย รอบนี้ไม่ได้มีความคิดว่าจะแก้แบบอัตโนมัติเลย
เราแค่เขียน TUI รับ input เป็นข้อความส่งผ่านไปให้ Intcode แล้ว print result ออกมา
ระหว่างเล่นก็จะเริ่มเจอความลำบาก เจอสิ่งที่โจทย์ไม่ได้บอก ก็ต้อง kill โปรแกรมแล้วเพิ่ม feature เข้าไป support เรื่อยๆ

ลองดู feature ที่ผมใส่เพื่อเล่นเกมในโจทย์นี้กัน
- short key: คำสั่งที่ใช้สื่อสารกับโปรแกรม Intcode นั้นค่อนข้างยาว
โดยเฉพาะคำสั่ง take กับ drop ที่ต้องพิมพ์ชื่อ item แบบเต็มๆ เช่นเจอ mouse เราก็ต้องพิมพ์ว่า `take mouse`
พอไปเจอ item ชื่อ `space law space brochure` ก็ลาก่อน ไม่มานั่งพิมพ์หรอกโว้ย
ก็เลยเกิดเป็น short key feature ขึ้นมา แทนที่จะพิมพ์คำสั่งเต็มๆ ให้พิมพ์แค่ตัวอักษรเดียวแทน:
    - n: ส่งคำสั่ง north
    - e: ส่งคำสั่ง east
    - s: ส่งคำสั่ง south
    - w: ส่งคำสั่ง west
    - t \<n\>: ส่งคำสั่ง take <item ลำดับที่ n ที่ Intcode บรรยายออกมา>
    - d \<n\>: ส่งคำสั่ง drop <item ลำดับที่ n ใน inventory>
    - i: ทีแรกเป็นการส่งคำสั่ง inv เพื่อลิสต์ของทั้งหมดที่มี แต่ตอนหลังผมเปลี่ยนมา maintain ตัว inventory เอง
    คำสั่งนี้ก็ยังเป็นการ print inventory ออกมาอยู่ดี แต่ไม่ได้ส่งคำสั่งไปที่ Intcode แล้ว
- เพิ่มคำสั่ง look เพื่อให้ print ข้อความบรรยายห้องปัจจุบันออกมาอีกครั้ง (ตอนแรกผมต้องใช้วิธีเดินไปอีกห้องแล้วเดินกลับมา น่าหงุดหงิดอยู่)
- เพิ่มคำสั่ง restore เพื่อย้อนกลับ ณ state ก่อนจะ take ของชิ้นล่าสุด
อันนี้เกิดขึ้นมาเพราะว่า บาง item ถ้าเราเก็บขึ้นมาแล้วจะทำอะไรต่อไม่ได้ คือ game over นั่นแหละ
ตายบ่อยๆ ก็ชักไม่สนุก ก็เลยเพิ่มให้ทุกครั้งก่อนจะส่งคำสั่ง take เราจะเก็บ game state ล่าสุดเอาไว้ก่อน
(game state ประกอบด้วย โปรแกรม Intcode, inventory, และคำบรรยายห้องปัจจุบัน)
จากนั้นเมื่อ restore เราก็จะเอา game state ที่กลับไว้มาใช้แทนได้
- circuit breaker: มันมี item ชิ้นหนึ่ง ชื่อ infinite loop ซึ่งมีเอฟเฟคตามที่ชื่อมันบอกนั่นแหละ
คือเมื่อเรา take มันขึ้นมา ตัวโปรแกรม Intcode ก็จะติด infinite loop ทันที
ผมก็เลยต้องเพิ่ม feature ให้คลาส Intcode คือให้เราตั้งค่ารอบการทำงานสูงสุดได้
เมื่อไหร่ที่เราสั่ง `run` แล้วมันทำงานเกินจำนวนรอบที่กำหนด ก็จะถือว่าติด infinite loop เราจะบังคับให้โปรแกรมเข้าสู่สถานะ crash คือพังไปเลย

[![](https://i.postimg.cc/L5yfnZ2W/p25.gif#center) *เก็บ Infinite loop ก็พังสิ! (แต่เรา restore ได้)*](https://postimg.cc/N2HLnFy8)


ด้วย feature เหล่านี้ ผมสำรวจดูห้องต่างๆ เก็บของที่ใช้งานได้มาได้ 8 ชิ้น แล้วก็เอาไปลองผิดลองถูกที่ห้อง sensor
ตรงนี้ก็อาศัยความถึกนิดหน่อย แต่โจทย์ไม่ได้ตั้งมาโหดร้ายมากเกินไปนัก คือทุกครั้งที่เราเข้าห้อง sensor
โปรแกรม Intcode จะตอบกลับมาว่า หนักเกินไป หรือเบาเกินไป (หรือน้ำหนักถูกต้องแล้ว)
ซึ่งมันมีของบางชิ้นที่เราถือเข้าไปแค่ชิ้นเดียวก็หนักเกินแล้ว เราก็รู้ว่าต้องไม่เอาอันนี้ไปด้วยแน่ๆ
หรือบางชิ้นที่เราเอาของทุกชิ้นเข้าไปยกเว้นมันชิ้นเดียว ก็ยังเบาเกินไป เราก็รู้ว่าต้องเอามันไปด้วยแน่ๆ
ดังนั้นมันพอจะเล่น manual แบบมีหลักการได้ ไม่ต้องลองทั้ง 256 วิธี

หลังจากเล่นผ่านแล้ว ไปแอบดูใน reddit ก็ถึงนึกได้ว่า จริงๆ จังหวะทดสอบ sensor มันต้องใช้คำสั่ง compare ใน Intcode แน่ๆ
ถ้าเราไปเพิ่ม debug info ที่คำสั่งนี้ ให้ print ออกมาว่า compare เลขอะไรบ้าง ก็น่าจะช่วยให้เห็นน้ำหนักของ item แต่ละชิ้นได้
โดยไม่ต้องลองผิดลองถูก ก็จะเล่นง่ายขึ้นอีกเยอะเลย

## ทิ้งท้าย

- ผมข้ามโจทย์ Intcode ที่คิดว่า ยังไม่น่าสนใจเท่าไหร่ไปหลายข้อเหมือนกัน (Day 17, 19, 23)
- โจทย์ที่ยกมา ก็จะเห็นได้ว่า ไม่ได้เป็นโจทย์โปรแกรมมิ่งเข้มข้นอะไรมากมาย แต่เน้นการพลิกแพลงแก้ปัญหามากกว่า
ที่จริงยังมีข้ออื่นๆ ที่ไม่ใช่โจทย์ Intcode ที่น่าสนใจเหมือนกัน ติดไว้คราวหน้า
- มีคนติดใจ Intcode จนสร้าง [tools](https://github.com/benediktwerner/intcode) ขึ้นมาครอบอยู่[หลายคน](https://www.reddit.com/r/adventofcode/comments/ejeaq8/another_intcode_vm_in_intcode_no_size_limit/)
เดี๋ยวว่างๆ อาจจะลองหาอะไรทำแนวๆ นี้ดูบ้าง


#### Notes

[^0]: โค้ดที่ใช้แก้โจทย์ทั้งหมดอยู่ใน [github](https://github.com/arkorwan/advent-of-code/tree/master/2019)
[^1]: ผมลอง search ดู ภาษาที่ใช้ชื่อ [Intcode](http://foldoc.org/INTCODE) นั้นมีอยู่จริงๆ แต่เป็นคนละภาษากับที่ใช้ในโจทย์ของเรา
[^2]: ผลลัพธ์สุดท้ายที่ได้จาก instructions มันไม่ตรงกับที่เราต้องการใน step(3) ซะทีเดียว คือมี ¬A ในวงเล็บเกินมาอันนึง แต่สอง expression นี้มัน equivalent กัน คล้ายๆ กับที่ p→q&nbsp;≡&nbsp;p→(p→q) ไม่เชื่อก็ลอง prove ดูสิ!