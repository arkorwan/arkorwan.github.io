---
layout: post
title: Advent of Code 2019 part 1 -- Intcode Computer Challenge 
tags: [programming]
---

ช่วงปลายปีที่แล้วมี[เพื่อน](https://twitter.com/PrachP)แนะนำให้รู้จักเว็บ [Advent of Code](https://adventofcode.com/2019)
ซึ่งก็เป็นเว็บแนว programming contest อีกเว็บหนึ่ง แต่มีความแตกต่าง คือตัวปัญหาถูกออกแบบมาในแนว puzzle ซะมากกว่า
คือไม่ได้ระบุ input/output มาแบบชัดเป๊ะแบบเว็บแนวนี้ทั่วๆ ไป แต่คนเล่นต้องพยายามแกะ requirement ที่แอบซ่อนไว้เอาเองด้วย
บางทีต้องทดลองรันโปรแกรมแบบครึ่งๆ กลางๆ เพื่อ probe ดูปัญหาว่าต้องรองรับเคสแปลกๆ แค่ไหน หรือบางข้อก็แก้โจทย์แบบ interactive ได้เลย
เป็นความท้าทายที่แตกต่างไปจากโจทย์ programming ปกติ

โจทย์มีทั้งหมด 25 วัน แต่ละวันเป็นปัญหาสองข้อ ข้อง่ายกับข้อยาก ต่อเนื่องกัน ยกเว้นวันสุดท้ายที่มีแค่ข้อเดียว รวมทั้งหมด 49 ข้อ
มีหลายข้อที่น่าสนใจ และหลายข้อที่เป็นโจทย์ต่อเนื่องกัน คือการสร้าง interpreter เพื่อรัน machine language ตัวหนึ่ง ซึ่งก็คือหัวข้อของเราในโพสนี้

## 'Intcode Computer'

ประมาณครึ่งหนึ่งของปัญหาทั้งหมดเป็นโจทย์ที่ให้เราสร้างโปรแกรมเพื่อรัน machine language ซึ่งทางเว็บตั้งชื่อไว้ว่า Intcode Computer[^1]
โจทย์ข้อแรกๆ (วันที่ 2, 5, 7, 9) จะเป็นการค่อยๆ เพื่ม spec ให้ภาษานี้ ข้อหลังๆ ของโจทย์ชุดนี้คือเราจะได้ input มาเป็นโปรแกรม Intcode เลย
แล้วเป็นหน้าที่ของเราที่ต้องเขียน interface โต้ตอบกับโปรแกรมที่ได้มา เหมือนได้กลับไปเรียนเขียนโค้ดกับพวก logic board โดยตรงอีกครั้ง ฮ่าๆ

ดู Spec ที่สมบูรณ์ของ Intcode ได้[ที่นี่](https://esolangs.org/wiki/Intcode)
ตรงนี้ขอสรุปย่อๆ ว่า Intcode มีความสามารถในการคำนวณ การเปรียบเทียบ flow control และมี relative addressing mode ซึ่งเอาไว้ทำ function call ได้
ทั้งหมดนี้ทำให้ Intcode เป็นภาษาที่ Turing complete นั่นคือสามารถทำการคำนวณใดๆ ที่ turing machine ทำได้ทั้งหมด

นี่คือ [class IntCode](code TBD)[^0] ตามที่ spec กำหนด และมี public methods ให้ใช้งานได้ดังนี้

* push(input: Integer) -- รับเลขหนึ่งตัว ใส่ลงไปที่ input queue
* push_all(inputs: Array\[Integer\]) -- ใส่เลขทั้งหมดใน input array ลงไปที่ input queue
* push_string(input: String) -- รับ string แปลงเป็น ascii code ใส่ลงไปที่ input queue
* run -- run โปรแกรมไปจนกระทั่ง halt, หรือต้องการ input เพิ่มเติม (คือเจอ input instruction แล้วไม่มี input อยู่ใน input queue)
return output ที่ได้ทั้งหมดเป็น array
* run_string -- เหมือน run แต่แปลง output ที่ได้เป็น string โดยถือว่าเลขที่มีค่าน้อยกว่า 128 คือ ascii code, เลขที่มากกว่านั้นคือตัวเลขธรรมดา
* clone -- ทำ deep copy ของ state ปัจจุบันของโปรแกรม ออกมาอีก instance หนึ่ง

ลองมาดูโจทย์ที่น่าสนใจกัน

## [Day 11](https://adventofcode.com/2019/day/11)

ข้อนี้เป็นข้อแรกหลังจาก Intcode spec สมบูรณ์ 
เราจะได้ input มาเป็นโปรแกรม Intcode ซึ่งควบคุมหุ่นยนต์เพื่อทาสีบน square grid
โปรแกรมจะอ่านค่าสีบนพื้น (0 หรือ 1) แล้วจะ return สีที่ต้องทาทับลงไป กับทิศทางว่าจะให้หันซ้ายหรือขวา
จนกระทั่งเจอ halt instruction ก็หยุดทำงาน

Part 1 ถามว่า ถ้า input แรกเป็น 0 หุ่นจะทาสีลงไปกี่ช่อง

Part 2 ให้เปลี่ยน Input แรกเป็น 1 แล้วถามว่าเราเห็นตัวอักษรอะไรบนพื้น ผมก็แบบ งงๆ ว่าอักษรอะไรวะ แต่ก็ลองรันดู แล้วก็ได้ output หน้าตาเป็นแบบนี้

<div class='asciiart-container'><pre class='asciiart'>
 ■  ■   ■■  ■■  ■      ■■ ■■■■ ■■■■ ■  ■   
 ■  ■    ■ ■  ■ ■       ■    ■ ■    ■  ■   
 ■■■■    ■ ■  ■ ■       ■   ■  ■■■  ■■■■   
 ■  ■    ■ ■■■■ ■       ■  ■   ■    ■  ■   
 ■  ■ ■  ■ ■  ■ ■    ■  ■ ■    ■    ■  ■   
 ■  ■  ■■  ■  ■ ■■■■  ■■  ■■■■ ■    ■  ■   
</pre>
<br><em>HJALJZFH!</em>
</div>

เป็นตัวอักษรจริงด้วย!

ที่จริงโจทย์ข้อนี้ไม่ได้ tricky อะไร เราก็แค่เก็บพิกัดที่ทาสีไปแล้วไว้ใน hash อันหนึ่ง แล้วก็ simulate ไปจนจบ
แต่มันเริ่มทำให้ผม appreciate อยู่สองอย่าง

อย่างแรกคือ เฮ้ย ไอ้โปรแกรม Intcode (และคนตั้งโจทย์) นี่มันไม่ธรรมดานะเนี่ย
ทำงานได้ซับซ้อนเลยทีเดียว คือจริงๆ ถ้าเห็นเป็นโค้ดใน high-level langauge ที่เราใช้กันทั่วไปมันก็คงเฉยๆ
แต่พอ input มันเป็น low level เป็นเลขยาวๆ เราก็เลยรู้สึกประทับใจซะงั้น! ถึงแม้จริงๆ คนตั้งโจทย์เค้าก็ต้อง generate เลขนี่ด้วย compiler
จาก high-level ซักภาษานั่นแหละ

อีกอย่างก็คือ เราจะไม่ค่อยเจอโจทย์ลักษณะนี้ในที่อื่นๆ
คือถ้าเป็นโจทย์ที่ตรวจด้วย automate checker ตามปกติ เค้าก็จะต้องบอกมาอย่างละเอียดว่า ตัวอักษร 26 ตัวนี่มันหน้าตาเป็นยังไง
ซึ่งมันทำให้ขาด suspense ที่เราจะ print ได้อะไรออกมาก็ไม่รู้ อันนี้แหละคือเสน่ห์ของ Advent of Code

## [Day 13](https://adventofcode.com/2019/day/13)

ข้อนี้เพิ่มความซับซ้อนของโปรแกรม Intcode ขึ้นไปอีกระดับ

Part 1 ไม่มี input อะไร โปรแกรมจะ output เลขออกมายาวๆ เป็นตำแหน่งของ game object เลขทุกๆ 3 ตัวจะบอกพิกัด x,y และบอกว่า
ตำแหน่งนั้นเป็น object อะไร กำแพง บล็อก ลูกบอล paddle หรือที่ว่าง โจทย์ถามง่ายๆ ว่ามี tile ที่เป็นบล็อกอยู่กี่อัน ก็แค่นับแล้วตอบ ง่ายๆ

แต่เราก็อยากรู้ว่าแล้วหน้าตาของเกมมันเป็นยังไง ก็เลยลองเขียนให้มัน print ออกมาดู

<div class='asciiart-container'><pre class='asciiart'>
########################################
#                                      #
#   ■  ■■■■ ■  ■  ■■■■     ■ ■ ■■■ ■   #
# ■■■ ■■  ■ ■■■■■■  ■■   ■■  ■■ ■■■■ ■ #
#  ■■ ■■■■ ■■■■ ■ ■■  ■■■ ■■■■■■  ■■   #
# ■■■■ ■■■■ ■■■■ ■■   ■     ■  ■■ ■  ■ #
# ■■■■■ ■ ■ ■ ■■■■ ■ ■■■ ■■■■■■ ■■■ ■  #
#  ■ ■■■■ ■  ■ ■■     ■■■  ■ ■■ ■■     #
#  ■  ■■■■■■■■■■■ ■  ■■■■■ ■■■  ■   ■  #
#  ■■ ■ ■■■     ■■■■■■■  ■  ■ ■■■■■ ■■ #
#  ■■■■ ■   ■■■ ■ ■      ■■ ■■  ■■■■■■ #
#   ■ ■  ■ ■ ■  ■ ■■  ■       ■■ ■■■■  #
#  ■■■ ■ ■ ■■■■■■■■■■ ■   ■ ■ ■ ■■■■■■ #
# ■ ■ ■■  ■■■■■■■ ■■   ■■ ■■  ■ ■■■■   #
#  ■  ■■       ■     ■ ■■■  ■ ■■ ■■■■■ #
# ■  ■  ■■■   ■■■■■■■ ■■■■■■  ■■ ■  ■■ #
# ■■  ■■■■ ■■■■    ■ ■■■ ■   ■ ■    ■  #
# ■■ ■■■ ■■■■■■■■■■■■■        ■ ■■■■ ■ #
#                                      #
#                 O                    #
#                                      #
#                                      #
#                   =                  #
#                                      #
</pre></div>

มันคือ เกมคลาสสิกในตำนาน [Breakout](https://en.wikipedia.org/wiki/Breakout_(video_game)) นั่นเอง

โจทย์ใน Part 2 บอกให้เราใส่ input เข้าไปที่โปรแกรม Intcode เพื่อขยับ paddle ทำลายบล็อกให้หมด
แล้วให้เอาคะแนนที่ได้มาเป็นคำตอบ ก็คือบอกให้เราเคลียร์เกมนี้ให้ได้นั่นละ

ผมก็เลยคิดว่า งั้นเราทำเป็น interactive mode เขียน TUI ด้วย curses (ซึ่งก็ไม่เคยเขียนมาก่อนเลย)
แล้วเล่นเองจริงๆ เลยดีกว่า ผลออกมาเป็น [code](TBD) นี้

ซึ่งไม่เวิร์คครับผม แป่ว

สาเหตุก็คือ นี่ไม่ใช่ action game เหมือนอย่าง breakout จริงๆ แต่เป็น turn-based ต่างหาก!
คือทุกครั้งที่เราใส่ input เข้าไป จะขยับ paddle ได้ 1 ช่อง พร้อมๆ กันนั้น ลูกบอลก็จะขยับไป 1 ช่องเช่นกัน
คือเราไม่สามารถทำความเร็วแซงลูกบอลได้เลย ดังนั้นจึงต้องเลื่อน paddle ให้ track ตำแหน่งในแกน x ของลูกบอลไว้ตลอด
ขยับผิดข้างเมื่อไหร่ เรียกได้ว่าแทบจะแพ้ในทันที

ซึ่งงานแบบนี้มันเหมาะให้เครื่องทำมากกว่ามานั่งจิ้มเองแน่ๆ สุดท้ายก็เลยต้องเขียนเป็น [code](TBD) อยู่ดี
แต่ไหนๆ ก็อุตส่าห์ทำ interface ไว้แล้ว ผมก็เลยให้เก็บ interface นี้ไว้เป็น display แล้วมานั่งดูคอมเล่นแทน ฮ่าๆ

[![p13.gif](https://i.postimg.cc/J7ZxL4ZR/p13.gif#center)](https://postimg.cc/3Wrmjhtq)

## [Day 15](https://adventofcode.com/2019/day/15)

ข้อต่อไป ตัวโปรแกรม Intcode คราวนี้เป็นโปรแกรมควบคุมหุ่น โดยรับ input เป็นทิศ เหนือ-ใต้-ออก-ตก ให้หุ่นเดินตามสั่ง เพื่อไปให้ถึงจุดหมาย
โดยที่ในแต่ละคำสั่งเราจะได้ output กลับมาว่า เดินได้ เดินไม่ได้ (ติดกำแพง) หรือ ถึงเป้าหมายแล้ว

โจทย์ part 1 ถามว่า shortest path ในการไปให้ถึงเป้าหมายนั้น ยาวเท่าไหร่?

ปกติเวลาแก้โจทย์ shortest path ใน grid แบบนี้เราแก้ได้ง่ายๆ ด้วย flood-fill / breadth-first search
ก็คือเริ่มจากจุดสตาร์ต มีความยาว path เป็น 0 เราก็ค่อยๆ probe ออกไปหา cell ใหม่ๆ ถ้าได้ cell ใหม่ก็เพิ่มความยาว path ไปอีก 1
แล้วเก็บใส่ queue ไว้ เอา cell จากใน queue มาทำแบบนี้วนไปเรื่อยๆ ก็จะได้ความยาว path จากจุดสตาร์ตถึงทุก cell

ปัญหาก็คือ ผมไม่สามารถบังคับให้หุ่นวาร์ปจาก cell หนึ่งใน queue ไปยัง cell ถัดไป (ซึ่งไม่ได้อยู่ติดกัน) ได้ในทันที ต้องบังคับให้มันเดินไป
ก็เลยทำ flood-fill ลำบากละ ผมก็เลยเปลี่ยนไปคิดว่างานนี้ต้องเขียน maze solver แทนจริงๆ มั้ยนะ

แต่ก่อนอื่น ไหนๆ เราก็มีโค้ดเขียน interface จากข้อก่อนหน้านี้แล้ว ก็เอามาทำเป็น [interactive code](TBD) (อีกละ)
ให้เราคุมหุ่นแบบ manual ไปเลยดีกว่า คือถ้าเดินได้ก็จะวาดเป็นจุด (.) ออกมาว่าเดินไปแล้วนะ ถ้าเดินชนกำแพงก็วาดกำแพง (■) ออกมาเลย

งานนี้ ก็คล้ายๆ กับข้อที่แล้ว คือแก้ด้วยมือมันก็แก้ได้ แต่ให้คอมทำน่าจะดีกว่า ... แต่คราวนี้ผมกัดฟัน วาด map ออกมาจนได้เว้ย

<div class='asciiart-container'><pre class='asciiart'>
                                          
  ■■■■■ ■■■■■ ■■■■■ ■■■■■■■ ■■■■■ ■■■ ■■■ 
 ■.....■.....■.....■.......■.....■...■...■
 ■.■■■.■.■■■.■.■■■.■.■.■■■■■.■.■.■.■.■.■.■
 ■.■.■.■..X■.....■.■.■.......■.■.■.■...■.■ 
 ■.■.■.■■■■■.■■■■■.■.■■■■■■■■■.■■■.■■■■■.■
 ■...■.....■.■.....■.■...■...■...■.■.■...■
  ■■.■■■■■.■■■.■■■.■.■.■.■.■.■■■.■.■.■.■.■
 ■.■.■...■.■...■...■.■.■...■...■.■...■.■.■
 ■.■.■.■■■.■.■■■■■■■.■.■■■■■■■.■.■■■.■.■■ 
 ■.■.■.■...■.■.....■.■...■.....■.....■...■
 ■.■.■.■.■■■.■.■■■.■.■■■.■■■.■■■■■■■■ ■■.■
 ■...■.■...■.....■.■...■...■.■...■...■.■.■
 ■.■■■.■■■.■■■■■.■.■■■.■■■.■.■.■.■.■.■.■.■
 ■.....■.■.....■.■.........■...■.■.■...■.■
  ■■■■.■.■■■■■.■■■■■■■.■■■■ ■■■■.■.■■■■■.■
 ■...■.■.■...■.■.....■.■...■...■...■.....■
 ■.■.■.■.■.■.■.■.■■■.■.■.■.■.■.■■■■■.■■■.■
 ■.■.■.■...■.■...■...■.■.■...■.......■...■
 ■.■.■.■■■■■.■■ ■■.■■■■■.■.■■■■■■■■■■■.■■ 
 ■.■.■.........■.■.....■.■.■...■.....■.■.■
 ■.■.■■■■■■■■■.■.■■■■■.■.■■■.■.■■■.■■■.■.■
 ■.■.■.......■.■.....■^■.■...■...■.....■.■
 ■.■■■.■.■■■■■.■.■■■.■■■.■.■■■■■.■■■.■■■.■
 ■.■...■.....■...■...■...■.....■...■.....■
 ■.■.■■■■■■■.■■■■■.■■■■■.■■■■■.■■■.■■■■■.■
 ■.■.■.....■.....■.....■...■...■.■.■.....■
 ■.■.■■■.■■■■■■■.■■■■■.■.■■■.■■■.■.■■■■■■ 
 ■.■.■...■.....■.....■.■.........■.■.....■
 ■.■.■.■■■.■■■.■■■.■■■.■■■■■■■■■■■.■.■■■.■
 ■.■.■.......■...■...■...........■.....■.■
 ■.■.■■■.■■■■■■■.■■■.■■■■■■■■■■■.■■■■■■■.■
 ■.■...■...■.....■.■...■.......■.....■...■
 ■.■■■.■■■■■.■■■.■.■■■.■.■■■.■.■■■■■.■.■■ 
 ■...■.■.....■...■...■.■.■.■.■...■...■...■
  ■■.■.■.■■■■■.■■■.■.■.■.■.■.■■■■■.■■■■■.■
 ■...■.■...■...■...■.■.■...■.....■.■.....■
 ■.■■■.■.■.■■■.■■■■■.■.■■■.■■■■■.■.■.■■■.■
 ■.....■.■...■...■...■.....■.■...■...■.■.■
 ■.■■■■■■■■■.■■■.■.■.■■■■■■■.■.■■■■■■■.■.■
 ■...........■.....■.........■...........■
  ■■■■■■■■■■■ ■■■■■ ■■■■■■■■■ ■■■■■■■■■■■ 
                                          
</pre>
<br><em>start ตรงกลางที่ตำแหน่ง ^ ไปจบซ้ายบนที่ X</em>
</div>

ส่วน part 2 นั้นแค่ให้หา cell ที่อยู่ไกลจากจุดเป้าหมายมากที่สุด ซึ่งตอนนี้เรามี map ทั้งหมดแล้ว ก็แค่ใช้ flood-fill หาคำตอบได้ง่ายๆ

หลังจากส่งคำตอบไปแล้ว ผมไปแอบดูใน reddit ก็ได้ไอเดียเพิ่มมาว่า จริงๆ part แรก มันก็แก้ด้วย flood-fill ได้แหละ
ที่ผมติดอยู่ตอนแรกก็คือเราไม่สามารถวาร์ปหุ่นไปมาได้เพราะต้องให้มันเดินตามทาง
ตรงนี้ผมไปติดกับดัก คิดจริงจังกับเนื้อเรื่องว่า ตัวโปรแกรม Intcode นี่มันฝังอยู่ในตัวหุ่น บังคับหุ่นอยู่จริงๆ
ก็เลยไม่ได้นึกว่า ที่จริงเราสร้าง copy ของโปรแกรมใน state สำหรับแต่ละ cell ขึ้นมาก็ได้
ก็คือพอเดินไปถึง cell ไหน เราก็ clone โปรแกรมออกมา วางไว้ที่ cell นั้น
ทีนี้เราอยากจะวาร์ปไป cell ไหน ก็จะมีโปรแกรม Intcode ใน state ที่ถูกต้องให้เราใช้ได้ ไม่ต้องบังคับให้หุ่นมันเดินตามทางจริงๆ

clone method จึงถูกเพิ่มเข้าไปในคลาส Intcode ด้วยประการฉะนี้

## [Day 21](https://adventofcode.com/2019/day/21)

ที่ผ่านมาเราเจอเกม action/arcade เกมแนว maze กันแล้ว ทีนี้มาเป็นแนว platformer บ้าง

ตัวหุ่นในข้อนี้วิ่งจากซ้ายไปขวา แล้วต้องกระโดดข้ามช่องว่าง โจทย์ให้เราเขียน logic คุมหุ่นให้กระโดดอัตโนมัติจากสิ่งที่หุ่นเห็นข้างหน้า
logic ที่เขียนมีหน้าตาเป็นภาษาแนวๆ assembly language ชนิดหนึ่ง ซึ่งมี operator ให้ใช้แค่ AND, OR และ NOT
ถ้าตั้ง register ตัวนึง (J) ให้เป็น true หุ่นก็จะกระโดด
และมีข้อจำกัดให้เขียนได้แค่ 15 คำสั่งเท่านั้น ส่งเป็น input ให้ Intcode computer 
เมื่อเราใส่ logic เข้าไปแล้ว ตัวโปรแกรม Intcode จะรัน logic นั้นกับ test case ต่างๆ เพื่อดูว่ากระโดดผ่านทั้งหมดหรือไม่

ใน part 1 หุ่นมองเห็น 4 ช่องล่วงหน้า และการกระโดดแต่ละครั้งหุ่นจะกระโดดข้ามไป 3 ช่อง
(ซึ่งตรงนี้โจทย์ไม่ได้บอกมา ต้องเดาเอาเองจากตัวอย่างและการลองผิดลองถูก) เราจะวาง logic ยังไงดี?

ถ้าให้ `.` คือช่องว่าง, `#` คือพื้น และ `?` คือ wildcard เป็นพื้นหรือช่องว่างก็ได้ และช่องที่หุ่นอยู่ปัจจุบันคือช่องที่ i
ถ้ากระโดดจะไปอยู่ที่ i+4 ถ้าไม่กระโดดก็จะเดินไปที่ i+1

ผมได้กฎการกระโดดแบบนี้

- `.???` → JUMP! อันนี้คือถ้าช่องข้างหน้า (i+1) เป็นช่องว่าง เดินไปก็ตายสถานเดียว ยังไงก็ต้องกระโดด
- `???.` →  NOT JUMP! อันนี้ตรงกันข้าม คือช่อง i+4 เป็นช่องว่าง ถ้าโดดไปก็ตกพอดี ยังไงก็ต้องไม่กระโดด
- `####` → NOT JUMP! กรณีนี้เรามองได้ว่า สมมติช่อง i+4 เป็นช่องที่ดี เราก็สามารถกระโดดไปได้ หรือเดินไป 3 ครั้ง ก็ได้เหมือนกัน
แต่ถ้าเป็นช่องที่ไม่ดี ถ้าโดดไปแล้วคือจบเลย แต่ถ้าเลือกเดินไป เราจะมีข้อมูลเพิ่มขึ้นเรื่อยๆ และสามารถเปลี่ยนใจกระโดดหนีได้
ดังนั้นการเลือกเดินไปจึงเป็นทางเลือกที่เปิดโอกาสให้เรามากกว่า
- `#?.#` -> JUMP! case ที่ยังไม่ครอบคลุมโดยกฎข้างบนจะเหลืออยู่ 3 แบบ คือ `#.##`, `##.#` และ `#..#`
ซึ่งทั้ง 3 แบบนี้มีช่องว่างอยู่ ยังไงซะเราจะต้องกระโดดแน่ๆ ภายใน 3 turn ไอเดียตรงนี้ก็คือ ถ้ารู้ตัวแล้วว่าต้องกระโดด
ยิ่งโดดเร็วก็ยิ่งดี เพราะจะมีทางเลือกในอนาคตมากกว่า ซึ่งตอนหลังผมทดลองดูแล้ว พบว่าเช็คแค่ข่อง i+3 ก็พอ
ก็เลยกลายเป็นกฎแบบนี้

ทั้งหมดนี้เขียนเป็น expression (A คือช่อง i+1 เป็นพื้น, B คือ i+2, ...) ได้ว่า

~~~~
¬A ∨ (¬C ∧ D)
~~~~
หรือ
~~~~
(¬A ∨ ¬C) ∧ D
~~~~
สองแบบนี้ให้ผลต่างกันเล็กน้อยในกรณีที่ทั้ง A และ D เป็น false ทั้งคู่ ซึ่งก็คือทั้งช่อง i+1 และ i+4 เป็นช่องว่าง
ซึ่งไม่ว่าจะเลือกเดินหรือโดดก็ตายอยู่ดี ดังนั้นในทางปฏิบัติแล้วไม่ได้มีผลต่างกัน ผมเลือก implement แบบแรก
และสามารถรัน test ผ่านโดยใช้ 4 instructions

~~~~
NOT C J   # J ← ¬C
AND D J   # J ← J ∧ D --- expands to J ← ¬C ∧ D
NOT A T   # T ← ¬A
 OR T J   # J ← T ∨ J --- expands to J ← ¬A ∨ (¬C ∧ D)
~~~~

โจทย์ part 2 เพิ่มให้เรา lookahead ได้ 8 ช่อง จากเดิม 4 ช่อง ซึ่งแสดงว่า test case มันต้องซับซ้อนยิ่งขึ้น

ผมลองเอา solution จาก part 1 มาใช้กับ part 2 ก็จะเจอ test case ที่รันไม่ผ่าน แบบนี้

[![p21.gif](https://i.postimg.cc/0QmYPc6V/p21.gif#center)](https://postimg.cc/BLSLC5BF)

จะเห็นว่า เคสนี้ที่หุ่นเราโดดไม่ผ่าน ก็เพราะการกระโดดครั้งแรกมันกระโดดไปที่จุดตาย คือจุดที่ i+1 และ i+4 เป็นหลุมทั้ง
ดังนั้น step ต่อไปยังไงก็ตาย แสดงว่า logic เราต้องหลึกเลี่ยงการเข้าไปสู่จุดตายลักษณะนี้ด้วย

เราจะใช้ predicate dead(x) เพื่อบอกว่า ตำแหน่ง x เป็นจุดตาย
ซึ่งเรา define มันแบบ recursive ก็คือ ช่องที่ x จะเป็นจุดตาย ถ้า
1. มันเป็นหลุม หรือ
1. ช่อง x+1 และ x+4 เป็นจุดตายทั้งคู่

~~~~
dead(x) = ¬x ∨ (dead(x+1) ∧ dead(x+4))
~~~~

เราเอา expression จาก part 1 มาเขียนใหม่ได้เป็นแบบนี้
~~~~
dead(A) ∨ (¬C ∧ ¬dead(D))
~~~~
ซึ่งเราขยาย predicate ออกมาแค่ครั้งเดียวใน part 1 คราวนี้ถ้าเรา expand ออกไปอีก
~~~~
      dead(A) ∨ (¬C ∧ ¬dead(D))
(1) → (¬A ∨ (dead(B) ∧ dead(E))) ∨ (¬C ∧ ¬(¬D ∨ (dead(E) ∧ dead(H))))
(2) → (¬A ∨ (¬B ∧ ¬E)) ∨ (¬C ∧ ¬(¬D ∨ (¬E ∧ ¬H)))
(3) → ¬A ∨ ¬(B ∨ E) ∨ (¬C ∧ D ∧ (E ∨ H))
~~~~
ความจริงใน step (2) เรายังสามารถขยาย dead(B) กับ dead(E) ออกไปได้อีก แต่เราลองหยุดไว้แค่นี้ก่อน
ถ้ามันใช้ได้ก็ได้เลย ถ้าไม่ได้เดี๋ยวเรากลับมา expand เพิ่มได้
หลังจาก simplify ใน step (3) แล้ว เราเอามาเขียนเป็น instructions ได้แบบนี้[^2]
~~~~
NOT C J  # J ← ¬C
AND D J  # J ← J ∧ D --- expands to J ← ¬C ∧ D
 OR E T  # T ← E
 OR H T  # T ← T ∨ H --- expands to T ← E ∨ H
AND T J  # J ← J ∧ T --- expands to J ← ¬C ∧ D ∧ (E ∨ H)
NOT A T  # T ← ¬A
 OR T J  # J ← T ∨ J --- expands to J ← ¬A ∨ (¬C ∧ D ∧ (E ∨ H))
 OR B T  # T ← T ∨ B --- expands to T ← ¬A ∨ B
 OR E T  # T ← T ∨ E --- expands to T ← ¬A ∨ B ∨ E
NOT T T  # T ← ¬T     --- expands to T ← ¬(¬A ∨ B ∨ E)
 OR T J  # J ← T ∨ J --- expands to J ← ¬A ∨ ¬(¬A ∨ B ∨ E) ∨ (¬C ∧ D ∧ (E ∨ H))
~~~~


ซึ่งพอเอา instructions นี้ไป run ก็ผ่าน test case ได้ทั้งหมด

สรุปแล้ว ข้อนี้มันไม่ใช่โจทย์โปรแกรมมิ่งเลยซักนิด เป็นโจทย์ตรรกศาสตร์ แก้ได้ด้วยกระดาษปากกานี่ล่ะ

## [Day 25](https://adventofcode.com/2019/day/25)

ข้อสุดท้ายของ Intcode และก็เป็นข้อสุดท้ายของ Advent of Code มี part เดียว
เป็นเกมแนว text-based adventure
ตัวโปรแกม Intcode คราวนี้รับ input เป็นคำสั่งควบคุมตัวละคร
ให้เดินไปในห้องตามทิศ north / east / south / west
หรือ take/drop ของจาก inventory
ตัวโปรแกรมจะ return ข้อความออกมาเป็นคำบรรยายห้องปัจจุบัน

โจทย์บอกให้เราสำรวจฉาก เก็บของซึ่งจะมีน้ำหนักต่างๆ กัน หาห้องเป้าหมายซึ่งจะมีเซนเซอร์ตรวจจับน้ำหนัก
แล้วพยายามถือของให้มีน้ำหนักตรงกับค่าที่เซนเซอร์ต้องการ

แน่นอน ผมก็ทำเป็น interactive game ตรงๆ แล้วเล่นแบบ manual อีกเช่นเคย ไม่ได้มีความคิดว่าจะแก้แบบอัตโนมัติเลย
เราแค่เขียน TUI รับ input เป็นข้อความส่งผ่านไปให้ Intcode แล้ว print result ออกมา
แต่เล่นไปซักพักก็ต้อง kill โปรแกรมแล้วเพิ่ม feature เข้าไปเรื่อยๆ

- short key: คำสั่งที่ใช้สื่อสารกับโปรแกรม Intcode นั้นค่อนข้างยาว
โดยเฉพาะคำสั่ง take กับ drop ที่ต้องพิมพ์ชื่อ item แบบเต็มๆ เช่นเจอ mouse เราก็ต้องพิมพ์ว่า `take mouse`
พอไปเจอ item ชื่อ space law space brochure มานั่งพิมพ์เต็มๆ ก็ชักจะไม่สนุกซะแล้ว
ก็เลยเกิดเป็น short key feature ขึ้นมา แทนที่จะพิมพ์คำสั่งเต็มๆ ให้พิมพ์แค่ตัวอักษรเดียวแทน:
    - n: ส่งคำสั่ง north
    - e: ส่งคำสั่ง east
    - s: ส่งคำสั่ง south
    - w: ส่งคำสั่ง west
    - t 1: ส่งคำสั่ง take <item ลำดับที่ 1 ที่ Intcode บรรยายออกมา>
    - d 1: ส่งคำสั่ง drop <item ลำดับที่ 1 ใน inventory>
    - i: ทีแรกเป็นการส่งคำสั่ง inv เพื่อลิสต์ของทั้งหมดที่มี แต่ตอนหลังผมเปลี่ยนมา maintain ตัว inventory เอง
    คำสั่งนี้ก็ยังเป็นการ print inventory ออกมาอยู่ดี แต่ไม่ได้ส่งคำสั่งไปที่ Intcode แล้ว
- เพิ่มคำสั่ง look เพื่อให้ print ข้อความบรรยายห้องปัจจุบันออกมาอีกครั้ง (ตอนแรกผมต้องใช้วิธีเดินไปอีกห้องแล้วเดินกลับมา น่าหงุดหงิดอยู่)
- เพิ่มคำสั่ง restore เพื่อย้อนกลับ ณ state ก่อนจะ take ของชิ้นล่าสุด
อันนี้เกิดขึ้นมาเพราะว่า บาง item ถ้าเราเก็บขึ้นมาแล้วจะทำอะไรต่อไม่ได้ คือ game over นั่นแหละ
ตายบ่อยๆ ก็ชักไม่สนุก ก็เลยเพิ่มให้ทุกครั้งก่อนจะส่งคำสั่ง take เราจะเก็บ game state ล่าสุดเอาไว้ก่อน
(game state ประกอบด้วย โปรแกรม Intcode, inventory, และคำบรรยายห้องปัจจุบัน)
จากนั้นเมื่อ restore เราก็จะเอา game state ที่กลับไว้มาใช้แทนได้
- circuit breaker: มันมี item ชิ้นหนึ่ง ชื่อ infinite loop ซึ่งมีเอฟเฟคตามที่ชื่อมันบอกนั่นแหละ
คือเมื่อเรา take มันขึ้นมา ตัวโปรแกรม Intcode ก็จะติด infinite loop ทันที
ผมก็เลยต้องเพิ่ม feature ให้คลาส Intcode คือให้เราตั้งค่ารอบการทำงานสูงสุดได้
เมื่อไหร่ที่เราสั่ง `run` แล้วมันทำงานเกินจำนวนรอบที่กำหนด ก็จะถือว่าติด infinite loop เราจะบังคับให้โปรแกรมเข้าสู่สถานะ crash คือพังไปเลย

[![p25.gif](https://i.postimg.cc/L5yfnZ2W/p25.gif#center) *เก็บ Infinite loop!*](https://postimg.cc/N2HLnFy8)


ด้วย feature เหล่านี้ ผมสำรวจดูห้องต่างๆ เก็บของที่ใช้งานได้มาได้ 8 ชิ้น แล้วก็เอาไปลองผิดลองถูกที่ห้อง sensor
ตรงนี้ก็อาศัยความถึกนิดหน่อย แต่โจทย์ไม่ได้ตั้งมาโหดร้ายมากเกินไปนัก คือทุกครั้งที่เราเข้าห้อง sensor
โปรแกรม Intcode จะตอบกลับมาว่า หนักเกินไป หรือเบาเกินไป (หรือน้ำหนักถูกต้องแล้ว)
ซึ่งมันมีของบางชิ้นที่เราถือเข้าไปแค่ชิ้นเดียวก็หนักเกินแล้ว เราก็รู้ว่าต้องไม่เอาอันนี้ไปด้วยแน่ๆ
หรือบางชิ้นที่เราเอาของทุกชิ้นเข้าไปยกเว้นมันชิ้นเดียว ก็ยังเบาเกินไป เราก็รู้ว่าต้องเอามันไปด้วยแน่ๆ
ดังนั้นมันพอจะเล่น manual แบบมีหลักการได้ ไม่ต้องลองทั้ง 256 วิธี

หลังจากเล่นผ่านแล้ว ไปแอบดูใน reddit ก็ถึงนึกได้ว่า จริงๆ จังหวะทดสอบ sensor มันต้องใช้คำสั่ง compare ใน Intcode แน่ๆ
ถ้าเราไปเพิ่ม debug info ที่คำสั่งนี้ ให้ print ออกมาว่า compare เลขอะไรบ้าง ก็น่าจะช่วยให้เห็นน้ำหนักของ item แต่ละชิ้นได้
โดยไม่ต้องลองผิดลองถูก ก็จะเล่นง่ายขึ้นอีกเยอะเลย

## ทิ้งท้าย

- ผมข้ามโจทย์ Intcode ที่คิดว่า ยังไม่น่าสนใจเท่าไหร่ไปหลายข้อเหมือนกัน (Day 17, 19, 23)
- โจทย์ที่ยกมา ก็จะเห็นได้ว่า ไม่ได้เป็นโจทย์โปรแกรมมิ่งเข้มข้นอะไรมากมาย แต่เน้นการแก้ปัญหามากกว่า
ที่จริงยังมีข้ออื่นๆ ที่ไม่ใช่โจทย์ Intcode ที่น่าสนใจเหมือนกัน เดี๋ยวติดไว้โพสหน้า
- มีคนติดใจ Intcode จนสร้าง [tools](https://github.com/benediktwerner/intcode) ขึ้นมาครอบอยู่[หลายคน](https://www.reddit.com/r/adventofcode/comments/ejeaq8/another_intcode_vm_in_intcode_no_size_limit/)
เดี๋ยวว่างๆ อาจจะลองหาอะไรทำแนวๆ นี้ดูบ้าง


#### Notes

[^0]: โค้ดที่ใช้แก้โจทย์ผมเขียนด้วย ruby ล้วนๆ แต่ต้องออกตัวไว้ก่อนว่าหน้าตาอาจจะดูแปลกๆ unconventional หน่อย เพราะผมใช้ ruby เพื่อทำโจทย์พวกนี้อย่างเดียวเลย ไม่เคยใช้ทำ project จริงๆ จังๆ ซักที เขียนเองอ่านเองคนเดียวว่างั้นเถอะ
[^1]: ผมลอง search ดู ภาษาที่ใช้ชื่อ Intcode นั้นมีอยู่จริงๆ ([link](http://foldoc.org/INTCODE)) แต่เป็นคนละภาษากับที่ใช้ในโจทย์ของเรา
[^2]: ผลลัพธ์สุดท้ายที่ได้จาก instructions มันไม่ตรงกับที่เราต้องการใน step(3) ซะทีเดียว คือมี ¬A ในวงเล็บเกินมาอันนึง แต่สอง expression นี้มัน equivalent กัน พิสูจน์ได้ในทำนองเดียวกับ p→q&nbsp;≡&nbsp;p→(p→q)